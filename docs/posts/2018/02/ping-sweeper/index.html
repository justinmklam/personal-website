<!DOCTYPE html>
<html lang="en">

<head>
    <title>Synchronous vs Asynchronous Ping Sweep in C# Windows Form</title>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-85178257-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-85178257-1');
</script>


<script>
    var shiftWindow = function() { scrollBy(0, -70) };
    window.addEventListener("hashchange", shiftWindow);
    function load() { if (window.location.hash) shiftWindow(); }
</script>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content=

    "Life is better when you live asynchronously."

>
<meta name="author" content="Justin Lam">

<link href="/css/jmklam-portfolio-bootstrap.min.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Lato:400i,400|Roboto+Slab" rel="stylesheet">
<link href="/css/highlight-js.css" rel="stylesheet">
</head>

<body onload="load()">

    <!DOCTYPE html>
<html lang="en">


<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        
        <div class="navbar-header">
            <button id="hamburger-menu" type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            
            <a class="navbar-brand" href="http://justinmklam.com">Justin Lam</a>
            
        </div>
        
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                
				

                <li><a href="/view-all">Portfolio</a>
				
				
					<li><a href="/pages/about/">About</a></li>
				
					<li><a href="/pages/contact/">Contact</a></li>
				
					<li><a href="/blog">Blog</a></li>
				
					<li><a href="/files/Resume.pdf">CV</a></li>
				

            </ul>
        </div>
        
    </div>
    
</nav>
    
</html>

    
    <div class="container" id="page-container">
        
        <div class="col-sm-8 col-centered" id="blog">
            <br>
            <h2>Synchronous vs Asynchronous Ping Sweep in C# Windows Form</h2>
            
            <p class="datestamp-index"><span class="fa fa-calendar-o"></span>&nbsp Posted on February 3, 2018
<em>&nbsp &middot &nbsp&nbsp6 min read &nbsp &middot &nbsp
    
    <a href="/tags/programming">#programming&nbsp</a>
    
    <a href="/tags/c-sharp">#c sharp&nbsp</a>
    
</em></p>

            
            <a href=/imgs/blog-imgs/ping-sweeper/banner2.PNG>
                <img class="img-responsive" style="display:block; margin:auto; margin-bottom:16px" src="/imgs/blog-imgs/ping-sweeper/banner2.PNG">
            </a>
            

<p>As a mechatronics engineer (in training), sometimes I like to pretend that I also know how to program.</p>

<p>In my most recent adventures to software land at <a href="https://mistywest.com/">MistyWest</a>, I needed to write an application in C# that involved doing a ping sweep to find devices that were physically connected through ethernet. Since Google and Stack Overflow are my two best friends, I was able to find (what seemed to be) an off-the-net solution quite quickly.</p>

<p>However, despite this being a relatively well known objective with well-known libraries to accomplish it, my journey to developing a solution was not as easy as I originally thought. The following post outlines the things I tried before arriving to a working solution, which hopefully is at least mildly interesting and/or educational. Also if you&rsquo;re a software engineer reading this, please go easy on my code. Or not.</p>

<h3 id="first-attempt-some-ping-simple">First Attempt: Some-ping Simple</h3>

<p>A quick Google search showed that pinging addresses is dead simple in C#. Using the <code>System.Net.NetworkInformation</code> namespace, we can easily use the <code>Ping.Send()</code> command to check if a remote address is alive.</p>

<pre><code class="language-c#">using System.Net.NetworkInformation;

int timeout = 10;   //in ms

Ping p = new Ping();
PingReply rep = p.Send(&quot;192.168.1.1&quot;, timeout);

if (rep.Status == IPStatus.Success)
{
    //host is active
}
</code></pre>

<p>This is great if we only had a few addresses to ping, because unfortunately this method is unacceptably slow for a user waiting to see if any devices are found. Although <code>Ping.Send</code> has an overload to accept a timeout interval, it appears that setting very low values doesn&rsquo;t actually change much. From the <a href="https://msdn.microsoft.com/en-us/library/ms144955.aspx">MSDN docs</a>:</p>

<blockquote>
<p>When specifying very small numbers for timeout, the Ping reply can be received even if timeout milliseconds have elapsed.</p>
</blockquote>

<p>In practice, it seems that ~500ms is about the fastest threshold that can be set. Unfortunately, scanning 255 IP addresses this way will be excruciatingly slow (for both the developer and end user). And the search continues&hellip;</p>

<h3 id="second-attempt-jaime-lan-nister-pingslayer">Second Attempt: Jaime LAN-nister, Pingslayer</h3>

<p>A few more Googles later and I had what seemed to be the golden solution.</p>

<p>Thanks to <a href="https://stackoverflow.com/a/4042887">Tim Coker</a>, I thought I was mostly done my application already (knowledge is half the battle, right?). His console application worked wonderfully and was written in C#, which was great news since I was developing the application using Windows Forms. Instead of using the synchronous <code>Ping.Send()</code>, it harnessed the asynchronous <code>Ping.SendAsync()</code> along with the <code>CountdownEvent</code> class in <code>System.Threading</code>. However, upon copying the code into Windows Forms, it didn&rsquo;t seem to work. What gives?</p>

<pre><code class="language-csharp">/* Source: https://stackoverflow.com/a/4042887
 * Original author: Tim Coker
 */

using System;
using System.Diagnostics;
using System.Threading;
using System.Net.NetworkInformation;

namespace ConsoleApplication1
{
    class Program
    {
        static CountdownEvent countdown;
        static int upCount = 0;
        static object lockObj = new object();
        const bool resolveNames = true;

        static void Main(string[] args)
        {
            countdown = new CountdownEvent(1);
            Stopwatch sw = new Stopwatch();
            sw.Start();
            string ipBase = &quot;10.22.4.&quot;;
            for (int i = 1; i &lt; 255; i++)
            {
                string ip = ipBase + i.ToString();

                Ping p = new Ping();
                p.PingCompleted += new PingCompletedEventHandler(p_PingCompleted);
                countdown.AddCount();
                p.SendAsync(ip, 100, ip);
            }
            countdown.Signal();
            countdown.Wait();
            sw.Stop();
            TimeSpan span = new TimeSpan(sw.ElapsedTicks);
            Console.WriteLine(&quot;Took {0} milliseconds. {1} hosts active.&quot;, sw.ElapsedMilliseconds, upCount);
            Console.ReadLine();
        }

        static void p_PingCompleted(object sender, PingCompletedEventArgs e)
        {
            string ip = (string)e.UserState;
            if (e.Reply != null &amp;&amp; e.Reply.Status == IPStatus.Success)
            {
                Console.WriteLine(&quot;{0} is up: ({1} ms)&quot;, ip, e.Reply.RoundtripTime);
                lock(lockObj)
                {
                    upCount++;
                }
            }
            else if (e.Reply == null)
            {
                Console.WriteLine(&quot;Pinging {0} failed. (Null Reply object?)&quot;, ip);
            }
            countdown.Signal();
        }
    }
}
</code></pre>

<p>Apparently, console applications and Windows Forms are different beasts and deadlocks occur with the above code. According to <a href="https://stackoverflow.com/a/7767632">Hans Passant from another Stack Overflow thread</a>, the additional UI thread is the culprit:</p>

<blockquote>
<p>Winforms has a synchronization provider whereas console apps do not. The problem is that the <code>Ping</code> class makes a best effort to raise the <code>PingCompleted</code> event on the same thread that calls <code>SendAsync()</code>. So it tries to raise the event on the main thread, but that can&rsquo;t work since the main thread is blocked with the <code>countdown.Wait()</code> call. In a console app however, the <code>PingCompleted</code> event will be raised on a <code>ThreadPool</code> thread.</p>
</blockquote>

<p>Hm, turns out this problem wasn&rsquo;t as easy as copying and pasting random code off the internet. It also turns out that there are two different asynchronous ping methods in the same class. First on the list:</p>

<blockquote>
<p><code>Ping.SendAsync</code>: <strong>Asynchronously attempts</strong> to send an Internet Control Message Protocol (ICMP) echo message to a computer, and receive a corresponding ICMP echo reply message from that computer. - <a href="https://msdn.microsoft.com/en-us/library/system.net.networkinformation.ping.sendasync(v=vs.110).aspx">MSDN</a></p>
</blockquote>

<p>And the second:</p>

<blockquote>
<p><code>Ping.SendPingAsync</code>: Sends an Internet Control Message Protocol (ICMP) echo message to a computer, and receives a corresponding ICMP echo reply message from that computer <strong>as an asynchronous operation</strong>. - <a href="https://msdn.microsoft.com/en-us/library/system.net.networkinformation.ping.sendpingasync(v=vs.110).aspx">MSDN</a></p>
</blockquote>

<p>Doing a bit more research, a came across the <code>BackgroundWorker</code> class that&rsquo;s built into C# Winforms. However, it wasn&rsquo;t clear to me how <code>Ping.SendPingAsync()</code> would be dealt with in a single background thread. Although it wouldn&rsquo;t be on the UI thread, it seemed like each ping would need its own background thread to be truly asynchronous, which seemed like a clunky implementation&hellip;</p>

<h3 id="third-attempt-one-ping-to-rule-them-all-one-ping-to-find-them">Third Attempt: One Ping to Rule Them All, One Ping to Find Them</h3>

<p><a href="https://stackoverflow.com/questions/13406901/task-parallel-library-code-freezes-in-a-windows-forms-application-works-fine-a">https://stackoverflow.com/questions/13406901/task-parallel-library-code-freezes-in-a-windows-forms-application-works-fine-a</a></p>

<!-- <div class="row captioned-img">
    <a href=/imgs/blog-imgs/ping-sweeper/winform.png><img class="img-responsive img-content" src=/imgs/blog-imgs/ping-sweeper/winform.png /></a>
    <p class="caption">Simple Winform application to demonstrate the power of threads.</p>
</div> -->

<p>Introducing the <code>Task</code> class in <code>System.Threading.Tasks</code>! This was the cleanest (and easiest) method to integrate with `Ping</p>

<pre><code class="language-c#">private string BaseIP = &quot;192.168.1.&quot;;
private int StartIP = 1;
private int StopIP = 255;
private string ip;

private int timeout = 100;
private int nFound = 0;

static object lockObj = new object();
Stopwatch stopWatch = new Stopwatch();
TimeSpan ts;

public async void RunPingSweep_Async()
{
    nFound = 0;

    var tasks = new List&lt;Task&gt;();

    stopWatch.Start();

    for (int i = StartIP; i &lt;= StopIP; i++)
    {
        ip = BaseIP + i.ToString();

        System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping();
        var task = PingAndUpdateAsync(p, ip);
        tasks.Add(task);
    }

    await Task.WhenAll(tasks);

    stopWatch.Stop();
    ts = stopWatch.Elapsed;
    MessageBox.Show(nFound.ToString() + &quot; devices found! Elapsed time: &quot; + ts.ToString(), &quot;Single Threaded&quot;);
}

private async Task PingAndUpdateAsync(System.Net.NetworkInformation.Ping ping, string ip)
{
    var reply = await ping.SendPingAsync(ip, timeout);

    if (reply.Status == System.Net.NetworkInformation.IPStatus.Success)
    {
        lock(lockObj)
        {
            nFound++;
        }
    }
}
</code></pre>

<div class="row captioned-img">
    <a href=/imgs/blog-imgs/ping-sweeper/ping%20result%20-%20async.png><img class="img-responsive img-content" src=/imgs/blog-imgs/ping-sweeper/ping%20result%20-%20async.png /></a>
    <p class="caption">Asynchronous pings are light years faster! Half a second and we&#39;re rocking with all the pings we needed.</p>
</div>

<h4 id="synchronous-ping-sweep">Synchronous Ping Sweep</h4>

<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>

<pre><code class="language-c#">private string BaseIP = &quot;192.168.1.&quot;;
private int StartIP = 1;
private int StopIP = 255;
private string ip;

private int timeout = 100;
private int nFound = 0;

Stopwatch stopWatch = new Stopwatch();
TimeSpan ts;

public void RunPingSweep_Sync()
{
    nFound = 0;

    stopWatch.Start();
    System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping();

    for (int i = StartIP; i &lt;= StopIP; i++)
    {
        ip = BaseIP + i.ToString();
        System.Net.NetworkInformation.PingReply rep = p.Send(ip, timeout);

        if (rep.Status == System.Net.NetworkInformation.IPStatus.Success)
        {
            nFound++;
        }
    }

    stopWatch.Stop();
    ts = stopWatch.Elapsed;

    MessageBox.Show(nFound.ToString() + &quot; devices found! Elapsed time: &quot; + ts.ToString(), &quot;Single Threaded&quot;);
}
</code></pre>

<div class="row captioned-img">
    <a href=/imgs/blog-imgs/ping-sweeper/ping%20result%20-%20sync.png><img class="img-responsive img-content" src=/imgs/blog-imgs/ping-sweeper/ping%20result%20-%20sync.png /></a>
    <p class="caption">Result of 255 pings using a synchronous method. Nobody has 2 minutes to wait for a complete scan.</p>
</div>

<pre><code>$ nmap -sP 192.168.1.1-255
...
Nmap done: 255 IP addresses (15 hosts up) scanned in 34.73 seconds
</code></pre>

<p>Check out the full source code on <a href="https://github.com/justinmklam/ping-sweeper/blob/master/Ping%20Sweep%20Demo/Ping%20Sweep%20Demo/FormMain.cs">Github</a>.</p>


			
            <br>
            <div class="text-left">
                <a href="/blog">
                    <span style="font-size:0.83em" class="glyphicon glyphicon-menu-left"></span>Recent Posts
                </a>
            </div>
            <hr>
            <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'justinmklam';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


        </div>
        

    </div>	
    

	    
    <script src="http://justinmklam.com/js/jquery.js"></script>

    
    <script src="http://justinmklam.com/js/bootstrap.min.js"></script>

    
    <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
    <script src="https://use.fontawesome.com/ccb78cc113.js"></script>

    
    <script>
        $(document).ready(function(){
            $('#hamburger-menu').click(function(){
                $(this).toggleClass('open');
            });
        });
    </script>

</body>
    

<footer>
	<div class="col-lg-8 col-centered">
		<hr>
		<p class="text-center">&copy; 2018 Justin MK Lam</p>
	</div>
</footer>

</html>